<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Automation</name>
    </assembly>
    <members>
        <member name="T:Automation.AutomationForm">
            <summary>
            A Form derived class controls AutomationThread
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.IsAlive">
            <summary>
            Whether the thread is running
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.Aborted">
            <summary>
            Whether the thread was stopped by user
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.RegisterBossMode">
            <summary>
            Automatically register the {Ctrl-Alt-B} key which triggers boss mode (hide/show the target window)
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.BossMode">
            <summary>
            Whether boss mode is on
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.ThreadTickInterval">
            <summary>
            Thread tick interval, in milliseconds, 0 to disable ticking
            </summary>
        </member>
        <member name="P:Automation.AutomationForm.HideForm">
            <summary>
            Whether hide main form (using a notification ion?)
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.SetThread(Automation.AutomationThread)">
            <summary>
            Set the thread member
            <param name="thread">An object derived from AutomationThread</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.StartThread">
            <summary> 
            Start the thread
            <returns>Return true if the thread starts successfully, false otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.StopThread">
            <summary>
            Stop the thread
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.ToggleThread">
            <summary>
            Toggle the thread
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.Confirm(System.String)">
            <summary>
            Display a confirmation dialog with OK and Cancel buttons
            <param name="text">Message text</param> 
            <returns>Return true if the user clicks the OK button.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.Message(System.String,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxButtons)">
            <summary>
            Display a message dialog
            <param name="text">Message text.</param> 
            <param name="icon">Dialog icon, default is exclamation.</param>
            <param name="buttons">Dialog buttons, default is single OK.</param>
            <returns>Return the user choice.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadStart">
            <summary>
            Thread started
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadAbort">
            <summary>
            Thread aborted
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadStop">
            <summary>
            Thread stopped
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnHotKey(System.Int32)">
            <summary>
            The user pressed a registered hotkey (Pause and Cyrl-Alt-B are exclused)
            <param name="id">Hotkey id</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnThreadMessage(System.Int32,System.Int32)">
            <summary>
            Event received from the thread
            <param name="wParam">wParam</param>
            <param name="lParam">lParam</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnMessage(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Generic event received
            <param name="message">Message id</param>
            <param name="wParam">wParam</param>
            <param name="lParam">lParam</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.OnBossMode(System.Boolean)">
            <summary>
            Boss mode changed
            <param name="bossMode">Boss mode is currently on</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.RegisterMainKey(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary>
            Register the main hotkey which starts/stgops the thread
            </summary>
            <param name="key">Key value</param>
            <param name="modifiers">Modifiers（Ctrl, Alt, Shift）, can be combined with | operator</param>
            <returns>Return true if success, false otherwise.</returns>
        </member>
        <member name="M:Automation.AutomationForm.UnregisterMainKey">
            <summary>
            Unregister the main hotkey which starts/stgops the thread
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.RegisterHotKey(System.Int32,System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary>
            Register a hotkey, whenever the user presses it, the form will be notified
            <param name="id">Hotkey id</param>
            <param name="key">Key value</param>
            <param name="mods">Modifiers（Ctrl, Alt, Shift）, can be combined with | operator</param>
            <returns>Return true if success, false otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.UnregisterHotKey(System.Int32)">
            <summary>
            Unregister a hotkey
            <param name="id">Hotkey id</param>		
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.Form_OnLoad(System.Object,System.EventArgs)">
            <summary>
            Inherited forms must call base.OnFormLoad(sender, e) in their Form_Load
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.Form_OnClosing(System.Object,System.Windows.Forms.FormClosingEventArgs)">
            <summary>
            Inherited forms must call base.OnFormClosing(sender, e) in their Form_OnClosing
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.Form_OnClosed(System.Object,System.Windows.Forms.FormClosedEventArgs)">
            <summary>
            Inherited forms must call base.OnFormClosed(sender, e) in their Form_OnClosed
            </summary>
        </member>
        <member name="M:Automation.AutomationForm.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Override WndProc
            <param name="m">Message struct</param>		
            </summary>
        </member>
        <member name="T:Automation.AutomationThread">
            <summary>
            The abstract thread class interact with the target window
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.TargetWnd">
            <summary>
            Handle of the target window
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.ClientRect">
            <summary> 
            Client rectangle of the target window, top-left is always 0,0
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.ClientToScreen">
            <summary> 
            Win32 ClientToScreen offset
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.ScreenToClient">
            <summary> 
            Win32 ScreenToClient offset
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.LastError">
            <summary> 
            Thread error messages used by message window
            </summary> 
        </member>
        <member name="P:Automation.AutomationThread.EnableBeeps">
            <summary>
            Turn on/off beep sounds for thread start/stop
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.Alerting">
            <summary> 
            Start or stop sound alarm
            </summary>
        </member>
        <member name="P:Automation.AutomationThread.IsAlive">
            <summary> 
            Whether the thread is running
            </summary> 
        </member>
        <member name="P:Automation.AutomationThread.Aborted">
            <summary> 
            Whether the thread was aborted by user
            </summary> 
        </member>
        <member name="P:Automation.AutomationThread.Paused">
            <summary> 
            Pause or resume the thread
            </summary> 
        </member>
        <member name="M:Automation.AutomationThread.#ctor">
            <summary> 
            Default constructor
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Finalize">
            <summary> 
            Destructor
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Start(System.Windows.Forms.Form,System.Int32)">
            <summary> 
            Start the thread
            <param name="messageForm">The window which receives thread messages, usually the main form</param>
            <param name="tickInterval">Interval of the ticker, the ticker won't start if the parameter is 0</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Stop">
            <summary> 
            Stop the thread
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Sleep(System.Int32)">
            <summary> 
            Sleep the current thread
            <param name="milliseconds">Milliseconds</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Lock(System.Object)">
            <summary> 
            Sync lock
            <param name="obj">Object to lock, use this if null</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Unlock(System.Object)">
            <summary> 
            Sync unlock
            <param name="obj">Object to unlock, use this if null</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.FindTargetWnd">
            <summary>
            Find handle of the target window which the thread is dealing with
            </summary>
            <returns>Handle of the target window, or IntPtr.Zero if not exists</returns>
        </member>
        <member name="M:Automation.AutomationThread.PreStart">
            <summary> 
            A callback checking before the thread starts
            <returns>Return true to allow the thread to start, false otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.OnStart">
            <summary> 
            Thread started
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.OnStop">
            <summary> 
            Thread stopped
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.OnTick">
            <summary> 
            Called periodically during the thread execution
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.ThreadProc">
            <summary> 
            Thread work
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.PostMessage(System.Int32,System.Int32)">
            <summary> 
            Send a message to the message window
            <param name="wParam">wParam</param> 
            <param name="lParam">lParam</param> 		/// 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.FindWindow(System.String,System.String)">
            <summary>
            Static method to find a window using class and title
            </summary>
            <param name="windowClass">Class name of the window, null to ignore</param>
            <param name="windowName">Window title of the window, null to ignore</param>
            <returns></returns>
        </member>
        <member name="M:Automation.AutomationThread.IsTargetWndForeground">
            <summary> 
            Whether the target window is foreground
            <returns>Return true if the target window is foreground, false otherwise</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.SetTargetWndForeground">
            <summary> 
            Set the target window foreground		
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.DelayBeforeAction(System.Int32)">
            <summary> 
            Apply a delay before sending an action for stablity, also check for thread pause status.
            <param name="milliseconds">Delay in milliseconds</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.GetPixel(System.Int32,System.Int32)">
            <summary> 
            Read pixel RGB value from client area of the target window.
            <param name="x">X coords (relative to client).</param>
            <param name="y">Y coords (relative to client).</param>
            <returns>Return RGB value if success, 0 otherwise.</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.WaitForPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> 
            Keeps checking whether a pixel of the target window matches specified RGB values
            <param name="x">X coords (relative to client)</param> 
            <param name="y">Y coords (relative to client)</param> 
            <param name="color">The RGB value</param> 
            <param name="timeout">Maximum milliseconds before timeout, 0 to check infinitely</param>
            <param name="sleep">Sleep the running thread between two checks, in millisecond (minimum is 100ms) </param>
            <returns>Return true if the pixel matches before timeout, false otherwise</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.RGB(System.Byte,System.Byte,System.Byte)">
            <summary>
            Compose rgb values into an integer
            </summary>
            <param name="r">Value of r component</param>
            <param name="g">Value of g component</param>
            <param name="b">Value of b component</param>
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:Automation.AutomationThread.RGB(System.Drawing.Color)">
            <summary>
            Compose rgb values into an integer, unlike System.Drawing.Color, it eliminates alpha value
            </summary>
            <param name="color">Value of color</param>		
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:Automation.AutomationThread.GetRValue(System.Int32)">
            <summary>
            Extract the r component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the r component</returns>
        </member>
        <member name="M:Automation.AutomationThread.GetGValue(System.Int32)">
            <summary>
            Extract the g component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the g component</returns>
        </member>
        <member name="M:Automation.AutomationThread.GetBValue(System.Int32)">
            <summary>
            Extract the b component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the b component</returns>
        </member>
        <member name="M:Automation.AutomationThread.TranslateLocation(System.Int32,System.Int32)">
            <summary> 
            Client coords to screen coords
            <param name="x">Client x coords</param> 
            <param name="y">Client y coords</param> 
            <returns>Screen coords</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.TranslateLocation(System.Drawing.Point)">
            <summary> 
            Client coords to screen coords
            <param name="point">Client coords</param> 
            <returns>Screen coords</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.RegisterLocale(System.String)">
            <summary> 
            Register a new locale if not exists		
            <param name="name">Locale name, such as fr-FR, de-DE, ko-KR, etc</param>
            <returns>A Locale object</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Localize(System.String)">
            <summary> 
            Translate a text into its localized form using current system locale		
            <param name="key">The en-US form of the text</param>
            <returns>The localized text</returns>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseClick(System.Int32,System.Int32,System.Windows.Forms.MouseButtons)">
            <summary> 
            Click a mouse button inside the target window's client area
            <param name="x">Client x coords</param> 
            <param name="y">Client y coords</param> 
            <param name="button">Mouse button</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseMove(System.Int32,System.Int32)">
            <summary> 
            Move the cursor to the target window's client area
            <param name="x">Client x coords</param> 
            <param name="y">Client y coords</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseDown(System.Windows.Forms.MouseButtons)">
            <summary> 
            Press down a mouse button
            <param name="button">Mouse button</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseUp(System.Windows.Forms.MouseButtons)">
            <summary> 
            Release a mouse button
            <param name="button">Mouse button</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.MouseWheel(System.Boolean)">
            <summary> 
            Scroll the mouse wheel
            <param name="scrollUp">Wheel direction</param> 
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.KeyStroke(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary> 
            Send a keystroke	
            <param name="key">Keys value</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.SendChar(System.Char,Win32API.ModKeys)">
            <summary> 
            Send a character		
            <param name="value">Character value</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.SendChar(System.String,Win32API.ModKeys)">
            <summary> 
            Send a character
            <param name="name">Character name</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.SendString(System.String,System.Int32)">
            <summary> 
            Send a character		
            <param name="contents">The string contents to be sent</param>
            <param name="delay">Delay between each 2 characters, in milliseconds</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.KeyDown(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary> 
            Press a key		
            <param name="key">Keys value</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.KeyUp(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary> 
            Release a key		
            <param name="key">Keys value</param>
            <param name="mods">Modifiers</param>
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.IsKeyDown(System.Windows.Forms.Keys)">
            <summary>
            Check whether a key is currently held down
            </summary>
            <param name="key">Keys value</param>
            <returns>Return true if the specified key is held down, false otherwise.</returns>
        </member>
        <member name="M:Automation.AutomationThread.Dispose">
            <summary> 
            Dispose the object
            </summary>
        </member>
        <member name="M:Automation.AutomationThread.Dispose(System.Boolean)">
            <summary> 
            Release unmanaged resources such as device context
            </summary>
        </member>
        <member name="T:Automation.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Automation.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Automation.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Automation.Resources.Alert">
            <summary>
              Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
            </summary>
        </member>
        <member name="P:Automation.Resources.Start">
            <summary>
              Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
            </summary>
        </member>
        <member name="P:Automation.Resources.Stop">
            <summary>
              Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
            </summary>
        </member>
        <member name="T:MFGLib.Locale">
            <summary>
            Key-value map for locale strings
            </summary>
        </member>
        <member name="P:MFGLib.Locale.Item(System.String)">
            <summary>
            Get or set locale values by key
            </summary>
        </member>
        <member name="T:MFGLib.LocaleCollection">
            <summary>
            Locale collection
            </summary>
        </member>
        <member name="F:MFGLib.LocaleCollection.SystemLocale">
            <summary>
            Get system locale: en-US, zh-CN, zh-TW, etc
            </summary>
        </member>
        <member name="M:MFGLib.LocaleCollection.#ctor">
            <summary>
            Cobstructor
            </summary>
        </member>
        <member name="M:MFGLib.LocaleCollection.RegisterLocale(System.String)">
            <summary>
            Register a locale if not exists
            <param name="name">Name of the locale, must comply with System.Globalization.CultureInfo</param>
            <returns>The locale object</returns>
            </summary>
        </member>
        <member name="M:MFGLib.LocaleCollection.GetLocalizedString(System.String)">
            <summary>
            Retrieve a localized string in current system locale
            <param name="key">Key of localized string</param>
            <returns>The locale object</returns>
            </summary>
        </member>
        <member name="T:MFGLib.MemDC">
            <summary>
            The GDI GetPixel method only suits for single pixel fetching, and will freeze 
            the screen if a whole region of pixels need to be scanned quickly. ClientDC
            copies a region of pixels from client area to memory then access them, this solution
            improves the performance by hundreds times. It can also capture pixels of directX
            windows.
            </summary>
        </member>
        <member name="F:MFGLib.MemDC.COLOR_INVALID">
            <summary>
            Represents an invalid color value
            </summary>
        </member>
        <member name="P:MFGLib.MemDC.Bitmap">
            <summary>
            The underlying Bitmap object
            </summary>
        </member>
        <member name="M:MFGLib.MemDC.Capture(System.Drawing.Rectangle)">
            <summary>
            Capture a block of pixels from screen to memory
            </summary>
            <param name="rect">Boundary of data block</param>
            <returns>Return true if success, false otherwise</returns>
        </member>
        <member name="M:MFGLib.MemDC.Capture(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Capture a block of pixels from screen to memory
            </summary>
            <param name="x">X coord of screen</param>
            <param name="y">Y coord of screen</param>
            <param name="width">Width of data block</param>
            <param name="height">Height of data block</param>
            <returns>Return true if success, false otherwise</returns>
        </member>
        <member name="M:MFGLib.MemDC.GetPixel(System.Int32,System.Int32)">
            <summary> 
            Read pixel RGB value from data block.
            <param name="x">X coords of mem dc.</param>
            <param name="y">Y coords of mem dc.</param>
            <returns>Return RGB value if success, COLOR_INVALID otherwise.</returns>
            </summary>
        </member>
        <member name="M:MFGLib.MemDC.CaptureAndGetPixel(System.Int32,System.Int32)">
            <summary>
            Capture single pixel and read it
            </summary>
            <param name="x">X coords of screen.</param>
            <param name="y">Y coords of screen.</param>
            <returns>Return RGB value if success, COLOR_INVALID otherwise.</returns>
        </member>
        <member name="M:MFGLib.MemDC.WaitForPixel(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> 
            Keeps checking whether a pixel of the target window matches specified RGB values
            <param name="x">X coords of screen</param> 
            <param name="y">Y coords of screen</param> 
            <param name="color">The RGB value</param> 
            <param name="timeout">Maximum milliseconds before timeout, 0 to check infinitely</param>
            <param name="sleep">Sleep the running thread between two checks, in millisecond (minimum is 100ms) </param>
            <returns>Return true if the pixel matches before timeout, false otherwise</returns>
            </summary>
        </member>
        <member name="M:MFGLib.MemDC.Save(System.String)">
            <summary> 
            Save the memory block to a file, image formats are automatically determined by file extension.
            <param name="filePath">Destination file path, will be overwritten if exists.</param>
            </summary>
        </member>
        <member name="M:MFGLib.MemDC.RGB(System.Byte,System.Byte,System.Byte)">
            <summary>
            Compose rgb values into an integer
            </summary>
            <param name="r">Value of r component</param>
            <param name="g">Value of g component</param>
            <param name="b">Value of b component</param>
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:MFGLib.MemDC.RGB(System.Drawing.Color)">
            <summary>
            Compose rgb values into an integer, unlike System.Drawing.Color, it eliminates alpha value
            </summary>
            <param name="color">Value of color</param>		
            <returns>Integer form of rgb value</returns>
        </member>
        <member name="M:MFGLib.MemDC.GetRValue(System.Int32)">
            <summary>
            Extract the r component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the r component</returns>
        </member>
        <member name="M:MFGLib.MemDC.GetGValue(System.Int32)">
            <summary>
            Extract the g component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the g component</returns>
        </member>
        <member name="M:MFGLib.MemDC.GetBValue(System.Int32)">
            <summary>
            Extract the b component from an integer grb value
            </summary>
            <param name="color">Integer form of rgb value</param>
            <returns>Value of the b component</returns>
        </member>
        <member name="P:MFGLib.GenericThread.IsAlive">
            <summary>
            Check whether the thread is alive
            </summary>
        </member>
        <member name="P:MFGLib.GenericThread.IsBackground">
            <summary>
            Get/set whether the thread is background
            </summary>
        </member>
        <member name="P:MFGLib.GenericThread.Aborted">
            <summary>
            Check whether the thread was aborted (stopped by throwing a ThreadAbortException)
            </summary>
        </member>
        <member name="P:MFGLib.GenericThread.ThreadState">
            <summary>
            Retrive thread state
            </summary>
        </member>
        <member name="M:MFGLib.GenericThread.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:MFGLib.GenericThread.Dispose">
            <summary>
            Dispose the object
            </summary>
        </member>
        <member name="M:MFGLib.GenericThread.Start">
            <summary>
            Start the thread
            </summary>
        </member>
        <member name="M:MFGLib.GenericThread.Stop">
            <summary>
            Stop the thread
            </summary>
        </member>
        <member name="M:MFGLib.GenericThread.Lock(System.Object)">
            <summary>
            Lock an object
            </summary>
            <param name="target">Object to be marked exclusive</param>
        </member>
        <member name="M:MFGLib.GenericThread.Unlock(System.Object)">
            <summary>
            Unlock an object
            </summary>
            <param name="target">Object no longer exclusive</param>
        </member>
        <member name="M:MFGLib.GenericThread.Sleep(System.Int32)">
            <summary>
            Sleep the thread
            </summary>
            <param name="milliseconds">Duration in milliseconds</param>
        </member>
        <member name="M:MFGLib.GenericThread.WaitForSingleObject(MFGLib.GenericThread,System.Int32)">
            <summary>
            Wait for a thread to stop, the function only return after the thread stops or timeout occurred.
            </summary>
            <param name="thread">The target thread to be waited.</param>
            <param name="timeout">Timeout in milliseconds, 0 means infinite.</param>
            <returns></returns>
        </member>
        <member name="M:MFGLib.GenericThread.GetWorkerProc">
            <summary>
            Abstract member to be overridden, derived classes must provider a ThreadStart to start the thread, such like "new ThreadStart(_ThreadProc)"
            </summary>
            <returns></returns>
        </member>
        <member name="M:MFGLib.WorkerThread.OnStart">
            <summary>
            Called when the thread starts
            </summary>
        </member>
        <member name="M:MFGLib.WorkerThread.OnStop">
            <summary>
            Called when the thread is stopped
            </summary>
        </member>
        <member name="M:MFGLib.WorkerThread.ThreadProc">
            <summary>
            Thread working function
            </summary>
        </member>
        <member name="M:MFGLib.WorkerThread.GetWorkerProc">
            <summary>
            Provide ThreadStart to base class
            </summary>
            <returns></returns>
        </member>
        <member name="M:MFGLib.WorkerThread._ThreadProc">
            <summary>
            Internal thread process
            </summary>
        </member>
        <member name="P:MFGLib.TickThread.Interval">
            <summary>
            Interval between every 2 ticks, in milliseconds, default is 200 ms. Only set upon starting to ensure thread safe
            </summary>
        </member>
        <member name="M:MFGLib.TickThread.Start(System.Int32)">
            <summary>
            Start ticking
            </summary>
            <param name="interval">Interval between every 2 ticks</param>
        </member>
        <member name="M:MFGLib.TickThread.TickProc">
            <summary>
            Tick function, called every Interval
            </summary>
        </member>
        <member name="M:MFGLib.TickThread.ThreadProc">
            <summary>
            Thread working function
            </summary>
        </member>
        <member name="P:MFGLib.EventThread.OnStart">
            <summary>
            Called when the thread starts
            </summary>
        </member>
        <member name="P:MFGLib.EventThread.OnStop">
            <summary>
            Called when the thread is stopped
            </summary>
        </member>
        <member name="P:MFGLib.EventThread.ThreadProc">
            <summary>
            Thread working function
            </summary>
        </member>
        <member name="M:MFGLib.EventThread._ThreadProc">
            <summary>
            Internal thread process
            </summary>
        </member>
        <member name="P:MFGLib.TickEventThread.OnTick">
            <summary>
            Called on every tick 
            </summary>
        </member>
        <member name="P:MFGLib.TickEventThread.Interval">
            <summary>
            Interval between every 2 ticks, in milliseconds, default is 200 ms. Only set upon starting to ensure thread safe
            </summary>
        </member>
        <member name="M:MFGLib.TickEventThread.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:MFGLib.TickEventThread.Start(System.Int32)">
            <summary>
            Start the tick thread
            </summary>
            <param name="interval">Interval between every 2 ticks, in milliseconds</param>
        </member>
        <member name="M:MFGLib.TickEventThread._TickThreadProc">
            <summary>
            Internal tick process
            </summary>
        </member>
        <member name="T:MFGLib.EventThreadHandler">
            <summary>
            Type definition of event callback functions
            </summary>
        </member>
        <member name="T:Win32API.Hotkey">
            <summary>
            A helper class for system hot key registration
            </summary>
        </member>
        <member name="M:Win32API.Hotkey.RegisterHotKey(System.IntPtr,System.Int32,System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary>
            Register a hotkey
            </summary>
            <param name="hWnd">Handle of the window which will receive WM_HOTKEY event</param>
            <param name="id">Unique identity of the hotkey</param>
            <param name="vk">Key</param>
            <param name="mods">Modifiers, default is none</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Hotkey.UnregisterHotKey(System.IntPtr,System.Int32)">
            <summary>
            Unregister a hotkey
            </summary>
            <param name="hWnd">Handle of the window which was used to register the hotkey</param>
            <param name="id">Unique identity of the hotkey</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Hotkey.IsHotkeyEvent(System.Windows.Forms.Message@)">
            <summary>
            Check whether a window message is a WM_HOTKEY
            </summary>
            <param name="m">The message</param>
            <returns>Return the unique identity of the hotkey if it's a WM_HOTKEY, return -1 otherwise</returns>
        </member>
        <member name="T:Win32API.ModKeys">
            <summary>
            Modifier keys
            </summary>
        </member>
        <member name="F:Win32API.ModKeys.None">
            <summary>
            No modifier
            </summary>
        </member>
        <member name="F:Win32API.ModKeys.Shift">
            <summary>
            The SHIFT key is held down
            </summary>
        </member>
        <member name="F:Win32API.ModKeys.Control">
            <summary>
            The CONTROL key is held down
            </summary>
        </member>
        <member name="F:Win32API.ModKeys.Alt">
            <summary>
            The ALT key is held down
            </summary>
        </member>
        <member name="T:Win32API.Input">
            <summary>
            A helper class for keyboard and mouse input simulation
            </summary>
        </member>
        <member name="M:Win32API.Input.MouseMove(System.Int32,System.Int32)">
            <summary>
            Move the mouse to a specified screen location
            </summary>
            <param name="x">X coords (relative to screen)</param>
            <param name="y">Y coords (relative to screen)</param>
        </member>
        <member name="M:Win32API.Input.MouseDown(System.Windows.Forms.MouseButtons)">
            <summary>
            Press down a mouse button
            </summary>
            <param name="buttons">The button to be pressed</param>
        </member>
        <member name="M:Win32API.Input.MouseUp(System.Windows.Forms.MouseButtons)">
            <summary>
            Release a mouse button
            </summary>
            <param name="buttons">The button to be released</param>
        </member>
        <member name="M:Win32API.Input.MouseClick(System.Windows.Forms.MouseButtons)">
            <summary>
            Click a mouse button
            </summary>
            <param name="buttons">The button to be clicked</param>
        </member>
        <member name="M:Win32API.Input.MouseDblClick(System.Windows.Forms.MouseButtons)">
            <summary>
            Double-click a mouse button
            </summary>
            <param name="buttons">The button to be clicked</param>
        </member>
        <member name="M:Win32API.Input.MouseWheel(System.Boolean)">
            <summary>
            Scroll the mouse wheel
            </summary>
            <param name="scrollUp">Scroll direction</param>
        </member>
        <member name="M:Win32API.Input.ReleaseAllKeys">
            <summary>
            Release all keys if held down
            </summary>
        </member>
        <member name="M:Win32API.Input.RemoveRedundantMods(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary>
            Remove redundant modifiers which already contained in key
            </summary>
            <param name="key">The key</param>
            <param name="mods">Modifiers</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Input.KeyDown(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary>
            Press down a key
            </summary>
            <param name="key">The key to be pressed down</param>
            <param name="mods">Modifiers</param>
        </member>
        <member name="M:Win32API.Input.KeyUp(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary>
            Release a key
            </summary>
            <param name="key">The key to be released</param>
            <param name="mods">Modifiers</param>
        </member>
        <member name="M:Win32API.Input.KeyStroke(System.Windows.Forms.Keys,Win32API.ModKeys)">
            <summary>
            Stroke a key
            </summary>
            <param name="key">The key to be stroked</param>
            <param name="mods">Modifiers</param>
        </member>
        <member name="M:Win32API.Input.SetCursorPos(System.Int32,System.Int32)">
            <summary>
            Set cursor pos to specified screen location
            </summary>
            <param name="x">X coords (relative to screen)</param>
            <param name="y">Y coords (relative to screen)</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Input.GetCursorPos">
            <summary>
            Retrieve the cursor location
            </summary>
            <returns>Return a Point struct contains X and Y coords relative to screen</returns>
        </member>
        <member name="M:Win32API.Input.IsKeyDown(System.Windows.Forms.Keys)">
            <summary>
            Chec k whether a specified key is currently held down
            </summary>
            <param name="key">The key</param>
            <returns>Return true if the key is held down, false otherwise</returns>
        </member>
        <member name="T:Win32API.Window">
            <summary>
            a helper class for window manipulation
            </summary>
        </member>
        <member name="M:Win32API.Window.FindWindow(System.String,System.String)">
            <summary>
            Find a specified window
            </summary>
            <param name="className">Class name of the window, does not exam if null</param>
            <param name="windowName">Title text of the window, does not exam if null</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Window.IsWindow(System.IntPtr)">
            <summary>
            Check whether a window handle is valid
            </summary>
            <param name="hwnd">The handle to be examed</param>
            <returns></returns>
        </member>
        <member name="T:Win32API.Window.EnumWindowsCallBack">
            <summary>
            Delegate for EnumWindows, it will be called for every window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <param name="lParam">User defined parameter</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Window.EnumWindows(Win32API.Window.EnumWindowsCallBack,System.Int32)">
            <summary>
            Enumerate all top-level windows
            </summary>
            <param name="callback">The delegate to be called when every window is found</param>
            <param name="lParam">User defined parameter</param>
            <returns>Return true if the enumeration completed successfully, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetWindowText(System.IntPtr)">
            <summary>
            Retrieve title text of a window
            </summary>
            <param name="hWnd">Handle of the window</param>
            <returns>Return title text if the handle is valid, null otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetClassName(System.IntPtr)">
            <summary>
            Retrieve class name of a window
            </summary>
            <param name="hWnd">Handle of the window</param>
            <returns>Return class name if the handle is valid, null otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetWindowRect(System.IntPtr)">
            <summary>
            Retrieve boundary rectangle of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return boundary rectangle if the handle is valid, return an empty rectangle otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetClientRect(System.IntPtr)">
            <summary>
            Retrieve boundary rectangle of the client area a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return boundary rectangle of the client area if the handle is valid, return an empty rectangle otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ClientToScreen(System.IntPtr)">
            <summary>
            Retrieve client-to-screen offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ScreenToClient(System.IntPtr)">
            <summary>
            Retrieve screen-to-client offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.WindowToScreen(System.IntPtr)">
            <summary>
            Retrieve window-to-screen offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ScreenToWindow(System.IntPtr)">
            <summary>
            Retrieve screen-to-window offset of a window
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return a Point struct which contain X and Y offsets if the handle is valid, return an empty Point otherwise</returns>
        </member>
        <member name="M:Win32API.Window.GetForegroundWindow">
            <summary>
            Retrieve the foreground window
            </summary>
            <returns>Handle of the foreground window</returns>
        </member>
        <member name="M:Win32API.Window.SetForegroundWindow(System.IntPtr)">
            <summary>
            Set a window to foreground
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns></returns>
        </member>
        <member name="M:Win32API.Window.IsMinimized(System.IntPtr)">
            <summary>
            Check whether a window is miminized
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return true if the specified window is minimized, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.IsMaximized(System.IntPtr)">
            <summary>
            Check whether a window is maximized
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return true if the specified window is maxmized, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.IsWindowVisible(System.IntPtr)">
            <summary>
            Check whether a window is visible
            </summary>
            <param name="hwnd">Handle of the window</param>
            <returns>Return true if the window is visible, false otherwise</returns>
        </member>
        <member name="M:Win32API.Window.ShowWindow(System.IntPtr,System.Int32)">
            <summary>
            Display the window in specified way
            </summary>
            <param name="hwnd">Handle of the window</param>
            <param name="nCmdShow">How the window will be displayed</param>
            <returns></returns>
        </member>
        <member name="F:Win32API.Window.SW_HIDE">
            <summary>
            The window will be hidden
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWNORMAL">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_NORMAL">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWMINIMIZED">
            <summary>
            The window will be shown minimized and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWMAXIMIZED">
            <summary>
            The window will be shown maximized and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_MAXIMIZE">
            <summary>
            The window will be shown maximized and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWNOACTIVATE">
            <summary>
            The window will be shown in recent state, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOW">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_MINIMIZE">
            <summary>
            The window will be shown minimized, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWMINNOACTIVE">
            <summary>
            The window will be shown minimized, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWNA">
            <summary>
            The window will be shown in recent state, but will not be activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_RESTORE">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="F:Win32API.Window.SW_SHOWDEFAULT">
            <summary>
            The window will be shown normally and activated
            </summary>
        </member>
        <member name="M:Win32API.Window.GetDesktopWindow">
            <summary>
            Retrieve handle of the desktop window
            </summary>
            <returns></returns>
        </member>
        <member name="F:Win32API.Window.WM_USER">
            <summary>
            The win32 WM_USER, private window messages should be defined between WM_USER and 0x7FFF
            </summary>
        </member>
        <member name="F:Win32API.Window.WM_APP">
            <summary>
            The win32 WM_APP, global window messages should be defined between WM_APP and 0xBFFF
            </summary>
        </member>
        <member name="M:Win32API.Window.SendMessage(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Send a message to a window, the function will not return until the event handler returns
            </summary>
            <param name="hWnd">Handle of the window which will receive the message</param>
            <param name="Msg">Message identity</param>
            <param name="wParam">Win32 WPARAM</param>
            <param name="lParam">Win32 LPARAM</param>
            <returns>Return the value returned by the event handler</returns>
        </member>
        <member name="M:Win32API.Window.PostMessage(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Post a message to a window, the function returns immediately
            </summary>
            <param name="hWnd">Handle of the window which will receive the message</param>
            <param name="Msg">Message identity</param>
            <param name="wParam">Win32 WPARAM</param>
            <param name="lParam">Win32 LPARAM</param>
            <returns>Return non-zero if the function successful, return zero if failed</returns>
        </member>
    </members>
</doc>
